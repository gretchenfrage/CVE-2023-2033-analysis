Link to NIST advisory:
https://nvd.nist.gov/vuln/detail/CVE-2023-2033

Link to Google's internal bug tracker, which is still not publically visible:
https://bugs.chromium.org/p/chromium/issues/detail?id=1432210

However the NIST advisory does describe it as a a CWE-843 'Type Confusion' type
bug: https://cwe.mitre.org/data/definitions/843.html

The general description of which states:
> The product allocates or initializes a resource such as a pointer, object, or variable using one type, but it later accesses that resource using a type that is incompatible with the original type. 

article from thehackernews.com: https://thehackernews.com/2023/04/google-releases-urgent-chrome-update-to.html

States:

> CVE-2023-2033 also appears to share similarities with CVE-2022-1096, CVE-2022-1364, CVE-2022-3723, and CVE-2022-4262 ‚Äì four other actively abused type confusion flaws in V8 that were remediated by Google in 2022.


Some apparent exploit enthusiast on Twitter states: https://twitter.com/mistymntncop/status/1650291423626022912

> Really curious how CVE-2023-2033 can be exploited. Error.captureStackTrace can place a "stack" getter and private property on the JSGlobalObject. But then what ?
> What is significant about JSGlobalObject/JSGlobalProxy vs the normal JSObject  ?

Approach: define those terms

Documentation for V8's stack trace API:

https://v8.dev/docs/stack-trace-api

JSGlobalProxy is more or less an application of object proxy used in the context of iframes (?)


Jacob believes (I don't know how they reached this conclusion) that this commit was the immediate patch for the bug:
https://chromium-review.googlesource.com/c/v8/v8/+/4417690
fa81078cca6964def7a3833704e0dba7b05065d8

    commit fa81078cca6964def7a3833704e0dba7b05065d8
    Author: Igor Sheludko <ishell@chromium.org>
    Date:   Wed Apr 12 16:12:16 2023 +0200

        [runtime] Make Error.captureStackTrace() a no-op for global object
        
        Bug: chromium:1432210
        Change-Id: I8aa4c3f1d9ecbfffce503085c2879416ff916c69
        Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/4417690
        Commit-Queue: Igor Sheludko <ishell@chromium.org>
        Reviewed-by: Tobias Tebbi <tebbi@chromium.org>
        Commit-Queue: Tobias Tebbi <tebbi@chromium.org>
        Auto-Submit: Igor Sheludko <ishell@chromium.org>
        Cr-Commit-Position: refs/heads/main@{#87045}

    diff --git a/src/builtins/builtins-error.cc b/src/builtins/builtins-error.cc
    index 01e016252c..14c06022a9 100644
    --- a/src/builtins/builtins-error.cc
    +++ b/src/builtins/builtins-error.cc
    @@ -35,6 +35,9 @@ BUILTIN(ErrorCaptureStackTrace) {
         THROW_NEW_ERROR_RETURN_FAILURE(
             isolate, NewTypeError(MessageTemplate::kInvalidArgument, object_obj));
       }
    +  if (object_obj->IsJSGlobalProxy()) {
    +    return ReadOnlyRoots(isolate).undefined_value();
    +  }
     
       Handle<JSObject> object = Handle<JSObject>::cast(object_obj);
       Handle<Object> caller = args.atOrUndefined(isolate, 2);

That appears to be a hacky temporary stopgap. By tracing that file's history in git, we see there is one more recent change to the file, which removed that change and performs an difference change:

79cdd69a1cfa9d3b4d9b6dec7203db4dabe618b4

This changes 500-600 lines of code across 25 files. Its message is this:

    [error] Define Error.stack property as a JavaScript accessor

    ... instead of the native data property.
    This fixes the JS spec violation when reading a data property does not
    expect any observable side effects. For example, OrdinaryGetOwnProperty
    (see https://tc39.es/ecma262/#sec-ordinarygetownproperty, step 4a).

    Differences to previous behaviour:
    - Error.stack is defined as a JavaScript accessor property.
    - all Error objects get a private "error_stack_symbol" field where
      the captured stack trace is stored (previously it was added only when
      the error was actually thrown which caused unnecessary transitions).
    - Error.captureStackTrace(obj) adds public "stack" accessor property
      and private "error_stack_symbol" property to given "obj".
    - calling "stack" getter/setter is a no-op in case receiver is not an
      "Error-like" object, i.e. it doesn't have a "error_stack_symbol"
      property and it doesn't have a prototype with such a property (the
      lookup stops at JSProxy or interceptor).
    - the "stack" getter walks the prototype chain from receiver until it
      finds a holder with the "error_stack_symbol" property which is then
      used for computing the result.
      This is slightly different from the previous behaviour in case
      receiver's prototype chain contains multiple error objects.
    - the "stack" setter walks the prototype chain from receiver until it
      finds a holder with the "error_stack_symbol" property and stores the
      value there.

    Drive-by: handle lazy accessor pairs in ObjectVisitorDeepFreezer.

    Bug: v8:5962
    Change-Id: I109d6fbbbdb9588d13ca86d217efd9a4a11d8447
    Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/4459251
    Reviewed-by: Toon Verwaest <verwaest@chromium.org>
    Reviewed-by: Shu-yu Guo <syg@chromium.org>
    Reviewed-by: Jakob Kummerow <jkummerow@chromium.org>
    Commit-Queue: Igor Sheludko <ishell@chromium.org>
    Cr-Commit-Position: refs/heads/main@{#87286}

That references Apr/20/2023 Draft ECMA-262 ECMAScript 2024 Language Specification
Section 10.1.5.1
https://tc39.es/ecma262/#sec-ordinarygetownproperty
Within Section 10: "Ordinary and Exotic Objects Behaviours"

Specifically step 4a which states:
> The abstract operation OrdinaryGetOwnProperty takes arguments O (an Object) and P (a property key) and returns a Property Descriptor or undefined. It performs the following steps when called:
> ...
> 3. Let X be O's own property whose key is P.
> 4. If X is a data property, then
> a. Set D.[[Value]] to the value of X's [[Value]] attribute.

Section 6.1.7 states: https://tc39.es/ecma262/#sec-object-type

    6.1.7 The Object Type

    An Object is logically a collection of properties. Each property is either a data property, or an accessor property:

        A data property associates a key value with an ECMAScript language value and a set of Boolean attributes.
        An accessor property associates a key value with one or two accessor functions, and a set of Boolean attributes. The accessor functions are used to store or retrieve an ECMAScript language value that is associated with the property.

    Properties are identified using key values. A property key value is either an ECMAScript String value or a Symbol value. All String and Symbol values, including the empty String, are valid as property keys. A property name is a property key that is a String value.

    An integer index is a String-valued property key that is a canonical numeric string and whose numeric value is either +0ùîΩ or a positive integral Number ‚â§ ùîΩ(253 - 1). An array index is an integer index whose numeric value i is in the range +0ùîΩ ‚â§ i < ùîΩ(232 - 1).

    Property keys are used to access properties and their values. There are two kinds of access for properties: get and set, corresponding to value retrieval and assignment, respectively. The properties accessible via get and set access includes both own properties that are a direct part of an object and inherited properties which are provided by another associated object via a property inheritance relationship. Inherited properties may be either own or inherited properties of the associated object. Each own property of an object must each have a key value that is distinct from the key values of the other own properties of that object.

    All objects are logically collections of properties, but there are multiple forms of objects that differ in their semantics for accessing and manipulating their properties. Please see 6.1.7.2 for definitions of the multiple forms of objects.

And to reiterate, the commit message for the longer-term fix indicates that Error.stack was changed from a data property to an accessor property

This thing: https://googleprojectzero.blogspot.com/2021/01/in-wild-series-chrome-exploits.html?m=1

Code from accessors.cc:

    void Accessors::ErrorStackGetter(
        v8::Local<v8::Name> key, const v8::PropertyCallbackInfo<v8::Value>& info) {
        const v8::FunctionCallbackInfo<v8::Value>& info) {
      Isolate* isolate = reinterpret_cast<Isolate*>(info.GetIsolate());
      HandleScope scope(isolate);
      Handle<Object> formatted_stack;
      Handle<JSObject> error_object =
          Handle<JSObject>::cast(Utils::OpenHandle(*info.Holder()));
      if (!ErrorUtils::GetFormattedStack(isolate, error_object)
      Handle<JSObject> maybe_error_object =
          Handle<JSObject>::cast(Utils::OpenHandle(*info.This()));
      if (!ErrorUtils::GetFormattedStack(isolate, maybe_error_object)
               .ToHandle(&formatted_stack)) {
        isolate->OptionalRescheduleException(false);
        return;
      }
      info.GetReturnValue().Set(Utils::ToLocal(formatted_stack));
      v8::Local<v8::Value> result = Utils::ToLocal(formatted_stack);
      CHECK(result->IsValue());
      info.GetReturnValue().Set(result);
    }

My ultimate suspicion:

When an error is thrown, it captures information about the stack trace immediately. However, nice textual formatting of this stack trace is performed lazily, when `.stack` is first accessed. The ECMAScript language specification divides objects' properties (eg. `.stack`) into "accessor properties," which are allowed to execute arbitrary logic when get and set, and "data properties," which are more restricted, including in that they are not supposed to produce observable side effects when get. Originally, errors' `.stack` property was implemented as a data property, which violated the specification as lazily populating the internal data for a formatted stack trace counts as an observable side effect. This could result in causing the optimizing JIT-compiler to emit machine code which operates on stale data and produces incorrect behavior as a result. It seems that an attacker found a way to exploit this in a way which involves tricking the `JSGlobalProxy` (which is likely to be involved in the context of iframes) into treating itself as an error object in some sense, and through that mechanism, somehow corrupting the heap. The first commit, a temporary stopgap, directly disables stack trace get on JSGlobalProxy. The second commit, a longer term solution, changes the implementation of the stack property so that it is now an accessor property rather than a data property, thus fixing the underlying specification nonconformance.
